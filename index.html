<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Firefly + Dahlia AV Timeline Calculator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Inter:wght@500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f6f3ea;
      --panel: rgba(18, 26, 38, 0.70);
      --panel-strong: rgba(14, 20, 30, 0.80);
      --border: rgba(96, 132, 158, 0.32);
      --accent: #72d8c5;          /* mint-light from effects */
      --accent-soft: rgba(114, 216, 197, 0.18);
      --accent-strong: rgba(114, 216, 197, 0.45);
      --teal: #4ab0c7;
      --text: #ffffff;
      --muted: #c6d4e1;
      --gold: #e8c36c;
      --lav: #7a8ac4;
      --ember: #ff8a3d;
      --control: rgba(90, 201, 255, 0.54);        /* eye teal */
      
      --control-strong: rgba(244, 176, 209, 0.54);/* eye pink */
      --control-border: rgba(255, 255, 255, 0.28);
      --bright-green: #c7e36a;
      --text-stroke: 0 transparent;
      --text-shadow-outline:
        -1px 0 0 rgba(0,0,0,0.9),
        1px 0 0 rgba(0,0,0,0.9),
        0 -1px 0 rgba(0,0,0,0.9),
        0 1px 0 rgba(0,0,0,0.9),
        -1px -1px 0 rgba(0,0,0,0.9),
        1px -1px 0 rgba(0,0,0,0.9),
        -1px 1px 0 rgba(0,0,0,0.9),
        1px 1px 0 rgba(0,0,0,0.9);
      --text-stroke: 1px rgba(0,0,0,0.9);
    }
    * { box-sizing: border-box; }
    body {
      font-family: "Space Grotesk", "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 20px 28px 40px;
      min-height: 100vh;
      background: url('Firefly Valentines.jpg') center/cover fixed;
      color: var(--text);
      backdrop-filter: none;
      box-shadow: none;
      text-shadow: none;
    }
    /* Apply readable outline to most text elements */
    h1, h2, h3, h4, h5, h6,
    p, span, label, button,
    input, select, option, textarea,
    .buff-title, .buff-sub, .subtitle,
    .card-title, .card-sub, .summary,
    table, th, td,
    .modal, .modal * {
      text-shadow: var(--text-shadow-outline);
    }
    .shell {
      max-width: 1340px;
      margin: 0 auto;
    }

    .hero {
      position: relative;
      max-width: 1340px;
      margin: 0 auto 22px;
      height: 200px;
      border-radius: 22px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.45);
      box-shadow: 0 12px 24px rgba(20,28,40,0.16);
      background:
        linear-gradient(115deg, rgba(255,255,255,0.75), rgba(246,243,234,0.7)),
        radial-gradient(circle at 22% 28%, rgba(114,216,197,0.1), transparent 44%),
        radial-gradient(circle at 80% 42%, rgba(122,138,196,0.08), transparent 46%);
    }
    .hero::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(160deg, rgba(0,0,0,0.18), rgba(0,0,0,0.06));
      z-index: 1;
      pointer-events: none;
    }
    .hero::after {
      content: "";
      position: absolute;
      inset: 0;
      background:
        radial-gradient(circle at 80% 50%, rgba(0,0,0,0), rgba(5,7,15,0.35)),
        linear-gradient(160deg, rgba(5,6,10,0.25), rgba(7,8,16,0.08));
    }
    .hero-content {
      position: relative;
      z-index: 2;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 24px 28px;
      gap: 6px;
    }
    .hero-title {
      font-size: 2rem;
      font-weight: 600;
      letter-spacing: 0.04em;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: nowrap;
      white-space: nowrap;
      text-shadow: var(--text-shadow-outline);
    }
    .hero-title span.emblem {
      font-size: 0.9rem;
      padding: 4px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.4);
      background: rgba(0,0,0,0.32);
      color: var(--gold);
      text-transform: uppercase;
      letter-spacing: 0.14em;
      text-shadow: var(--text-shadow-outline);
    }
    .hero-sub {
      font-size: 1rem;
      color: #ffffff;
      max-width: 100%;
      white-space: normal;
      text-shadow: var(--text-shadow-outline);
    }

    .panel {
      background: var(--panel);
      border-radius: 18px;
      padding: 18px 20px 20px;
      box-shadow: 0 12px 28px rgba(20, 28, 40, 0.18);
      border: 1px solid var(--border);
      margin-bottom: 20px;
      backdrop-filter: blur(4px);
      position: relative;
      overflow: hidden;
    }
    .av-panel { overflow: visible; }
    .panel::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 18% 10%, rgba(114,216,197,0.12), transparent 48%);
      pointer-events: none;
    }
    .panel::after {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 88% 0%, rgba(122,138,196,0.12), transparent 46%);
      pointer-events: none;
    }
    .panel-header {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
      margin-bottom: 10px;
    }
    h1 {
      font-size: 1.6rem;
      margin: 0 0 0.3rem;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    h1 span.mark {
      font-size: 0.8rem;
      padding: 3px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.25);
      background: rgba(0,0,0,0.35);
      color: #f7c266;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
    .subtitle {
      font-size: 0.92rem;
      color: #ffffff;
      margin-bottom: 0.2rem;
      max-width: 840px;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: stretch;
      background: linear-gradient(120deg, rgba(255,255,255,0.04), rgba(255,255,255,0));
      padding: 10px 10px 2px 10px; /* top, right, bottom (tighter), left */
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .controls-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: flex-start;
      justify-content: flex-start;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      height: 100%;
      justify-content: flex-start;
      align-items: flex-start;
      flex: 0 0 auto;
    }
    .control-group.spd-group { flex: 0 0 230px; }
    .control-group.buff-group { flex: 0 0 150px; gap: 20px; }
    .control-group.e5-group { flex: 0 0 165px; gap: 10px; }
    .control-group.ddd-group { flex: 0 0 280px; }
    .toggle-row {
      display: flex;
      gap: 12px;
      flex-wrap: nowrap;
      justify-content: flex-start;
      align-items: center;
    }
    .toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 0;
      font-size: 0.8rem;
      color: #ffffff;
    }
    .toggle-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
    }
    .buff-block {
      display: flex;
      align-items: flex-start;
      gap: 6px;
    }
    .buff-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
      line-height: 1.1;
    }
    .buff-title { font-weight: 600; color: var(--text); font-size: 1rem; }
    label.buff-title { color: var(--text); font-weight: 600; font-size: 1rem; }
    .buff-sub { color: #ffffff; font-size: 0.8rem; }
    label {
      font-size: 0.8rem;
      color: #ffffff;
      letter-spacing: 0.02em;
    }
    input[type="number"],
    input[type="range"] {
      width: 100%;
    }
    input[type="number"] {
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--control-border);
      background: linear-gradient(135deg, var(--control), var(--control-strong));
      color: var(--text);
      font-size: 0.9rem;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.08);
      text-indent: 1px;
    }
    input[type="number"]:focus-visible {
      outline: 1px solid var(--accent);
      box-shadow: 0 0 0 2px var(--accent-soft);
    }
    input[type="number"]:hover,
    select:hover,
    .ddd-adv:hover {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--accent-soft);
    }
    input[type="number"]:focus-visible,
    select:focus-visible {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--accent-soft);
    }
    input[type="range"] { accent-color: var(--accent); }

    /* Modal override input text color */
    #dddOverrideInput { color: #000000; }
    
    select {
      padding: 4px 10px;
      border-radius: 10px;
      border: 1px solid var(--control-border);
      background: linear-gradient(135deg, var(--control), var(--control-strong));
      color: var(--text);
      font-size: 0.85rem;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.08);
      height: 20px;
      text-indent: 1px;
      
      /*Forcing the background color to avoid OS-level theming issues. Not happy about this one, but this is something you can tweak.*/
      background-color: #646464;
    }
    select option {
      color: #000000;
      background: #ffffff;
      /* Added some ovrride to ensure readability */
      text-shadow: none;
      font-weight: normal;
    } 
    /* Compact gradient selects for DDD proc/rank rows */
    .ddd-proc-select {
      appearance: none;
      background: linear-gradient(135deg, var(--control), var(--control-strong));
      border: 1px solid var(--control-border);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.08);
      color: var(--text);
      height: 24px;
      line-height: 24px;
      padding: 0px 8px;
    }
    /* Match gradient/button styling for DDD distribution selects */
    .ddd-dist-select {
      appearance: none;
      background: linear-gradient(135deg, var(--control), var(--control-strong));
      border: 1px solid var(--control-border);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.08);
      color: var(--text);
      padding: 0px 8px;
    }
    .toggle-inline {
      flex: 1 1 100%;
      display: flex;
      flex-wrap: nowrap;
      gap: 10px;
      align-items: center;
    }
    .mini-panel {
      padding: 6px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: linear-gradient(120deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.06);
      height: 100%;
      display: grid;
      grid-template-columns: 1.2fr 0.8fr;
      grid-template-rows: auto 1fr;
      gap: 5px;
      align-items: stretch;
      position: relative;
    }
    /* Tighten vertical gap around the DDD mini-panel without changing its internal padding */
    .control-group.ddd-group .mini-panel {
      margin-top: -6px;
      margin-bottom: -6px;
    }
    .mini-panel-header {
      font-weight: 500;
      font-size: 0.85rem;
      color: #ffffff;
      margin-bottom: 2px;
      grid-column: 1;
      grid-row: 1;
    }
    .ddd-row { display: contents; }
    .ddd-column {
      display: flex;
      flex-direction: column;
      gap: 4px;
      grid-column: 1;
      grid-row: 2;
      min-width: 0;
    }
    .ddd-column select {
      height: 24px;
      line-height: 24px;
      width: 100%;
    }
    #dddModeSelect,
    #dddModeSelectModalProcs,
    #dddModeSelectModalOverride {
      height: 24px;
      line-height: 24px;
    }
    .e5-group select { width: 100%; }
    .phainon-select { width: 90px; height: 32px; }
    .ddd-adv {
      border: 1px solid var(--control-border);
      border-radius: 10px;
      min-height: 48px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-end;
      font-size: 0.85rem;
      color: var(--text);
      text-align: center;
      padding: 4px;
      gap: 4px;
      background: linear-gradient(135deg, var(--control), var(--control-strong));
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.06);
      cursor: pointer;
      transition: border-color 0.15s ease, box-shadow 0.15s ease, color 0.15s ease;
      align-self: end;
      width: 120px;
      grid-column: 2;
      grid-row: 2;
      height: auto;
    }
    .ddd-adv:hover {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--accent-soft);
      color: var(--text);
    }
    .ddd-adv-line { display: block; line-height: 1.1; }
    .ddd-gear { font-size: 1.2rem; }
    .muted-inline {
      font-size: 0.75rem;
      color: #ffffff;
      white-space: nowrap;
    }
    .phainon-select { padding: 6px 10px; height: 32px; width: 90px; }
    .toggle input { accent-color: var(--accent); }

    .summary {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 14px;
      font-size: 0.9rem;
      color: #ffffff;
    }
    .summary-item {
      background: linear-gradient(135deg, rgba(247,183,51,0.12), rgba(10,12,24,0.92));
      border-radius: 14px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.12);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.06);
    }
    .summary-label { color: #ffffff; }
    .summary-value { color: #f7c266; font-weight: 600; }

    .charts {
      display: flex;
      flex-wrap: wrap;
      gap: 18px;
      margin-top: 16px;
    }
    .chart-card { flex: 1; min-width: 360px; }
    .card-title {
      font-weight: 600;
      margin-bottom: 4px;
      font-size: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .card-sub {
      font-size: 0.82rem;
      color: #ffffff;
      margin-bottom: 8px;
    }
    .pill {
      font-size: 0.7rem;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      color: #ffffff;
      background: rgba(255,255,255,0.06);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      overflow: hidden;
      border-radius: 14px;
    }
    th, td {
      padding: 6px 9px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      text-align: left;
      white-space: nowrap;
      color: var(--text);
    }
    th {
      font-weight: 600;
      color: #e2e8f0;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: linear-gradient(120deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
    }
    tbody tr:nth-child(even) { background: rgba(255,255,255,0.02); }
    tbody tr:nth-child(odd) { background: rgba(255,255,255,0.04); }
    tbody tr:hover { background: rgba(247,183,51,0.12); transition: background 0.2s ease; }

    tr.event-phase td { color: var(--teal); font-weight: 600; }
    tr.event-phase td:first-child { color: var(--text); }
    tr.event-phase td:last-child { color: var(--text); }
    tr.event-eba td:nth-child(2) { color: #facc15; }
    tr.event-cc td:nth-child(2) { color: #f97316; font-weight: 600; }
    tr.event-skill td:nth-child(2) { color: #a5b4fc; }
    tr.event-ult td:nth-child(2) { color: var(--accent); font-weight: 600; }
    /* Color AV column when AA directly advanced an event (future mode) */
    tr.event-eba[data-aa-hit] td:last-child { color: #facc15; }
    tr.event-skill[data-aa-hit] td:last-child { color: #a5b4fc; }
    tr.event-ult[data-aa-hit] td:last-child { color: var(--accent); font-weight: 600; }

    /* AV band highlights for Scenario A */
    tr.range-a0 td { background-color: rgba(56,189,248,0.16); }
    tr.range-a1 td { background-color: rgba(234,179,8,0.16); }
    tr.range-a2 td { background-color: rgba(52,211,153,0.16); }
    tr.range-a3 td { background-color: rgba(251,113,133,0.16); }
    tr.range-a4 td { background-color: rgba(129,140,248,0.16); }

    /* AV band highlights for Scenario B */
    tr.range-b0 td { background-color: rgba(56,189,248,0.16); }
    tr.range-b1 td { background-color: rgba(234,179,8,0.16); }
    tr.range-b2 td { background-color: rgba(52,211,153,0.16); }
    tr.range-b3 td { background-color: rgba(251,113,133,0.16); }

    .av-col {
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.82rem;
    }

    .preset-row {
      display: flex;
      flex-wrap: nowrap;
      gap: 10px;
      margin-top: 8px;
      align-items: center;
      font-size: 0.78rem;
      color: #ffffff;
    }
    .inv-target { width: 220px; }
    .inv-target-input { max-width: 180px; }
    .preset-label { margin-right: 4px; min-width: 190px; display: inline-block; }
    .preset-btn {
      border-radius: 12px;
      border: 1px solid var(--control-border);
      background: linear-gradient(135deg, var(--control), var(--control-strong));
      color: var(--text);
      padding: 8px 12px;
      font-size: 0.85rem;
      min-width: 160px;
      flex: 0 0 160px;
      text-align: center;
      cursor: pointer;
      transition: transform 0.12s ease, border-color 0.12s ease, box-shadow 0.12s ease, color 0.12s ease;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.1);
      letter-spacing: 0.01em;
    }
    .preset-btn:hover {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--accent-soft);
      transform: translateY(-1px);
    }
    .preset-btn:active {
      transform: translateY(0);
    }
    .divider {
      border: none;
      border-top: 1px solid rgba(31,41,55,0.9);
      margin: 12px 0;
    }

    .panel-pin {
      border: 1px solid rgba(255,255,255,0.2);
      background: linear-gradient(120deg, rgba(255,255,255,0.08), rgba(255,255,255,0.04));
      color: var(--text);
      border-radius: 10px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 0.82rem;
      transition: all 0.15s ease;
    }
    .panel-pin:hover {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--accent-soft);
      transform: translateY(-1px);
    }
    .panel-pin:active {
      transform: translateY(0);
    }
    .av-panel.pinned .panel-pin {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--accent-soft);
      background: linear-gradient(120deg, rgba(247,183,51,0.16), rgba(255,255,255,0.08));
    }
    .av-panel.pinned {
      position: sticky;
      top: 0;
      z-index: 998;
      box-shadow: 0 24px 48px rgba(0,0,0,0.65);
      padding: 10px 14px;
      border-bottom-left-radius: 10px;
      border-bottom-right-radius: 10px;
    }
    .av-panel.pinned .panel-header { margin-bottom: 6px; }
    .av-panel.pinned h1 { margin: 0; font-size: 1.3rem; text-shadow: 0 6px 14px rgba(0,0,0,0.55); font-weight: 700; }
    .av-panel.pinned .subtitle { display: none; }
    .av-panel.pinned .controls { padding: 8px; gap: 10px; }
    .av-panel.pinned .control-group { min-width: 200px; }
    .av-panel.pinned .summary { display: none; }
    .hero.hidden {
      display: none;
    }

    /* Modal for advanced DDD settings */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.12);
      backdrop-filter: blur(4px);
      display: none;
      align-items: flex-start;
      justify-content: center;
      z-index: 999;
      padding: 32px 24px;
    }
    .modal.active { display: flex; }
    .modal-dialog {
      width: min(1200px, 96vw);
      max-height: 90vh;
      overflow: auto;
      background:
        linear-gradient(90deg, rgba(185,180,173,0.82) 0%, rgba(213,213,213,0.86) 55%, rgba(235,235,235,0.9) 100%),
        radial-gradient(circle at 22% 28%, rgba(114,216,197,0.07), transparent 44%),
        radial-gradient(circle at 80% 42%, rgba(122,138,196,0.05), transparent 46%);
      border-radius: 18px;
      border: 2px solid rgba(114,216,197,0.6);
      box-shadow: 0 12px 24px rgba(20,28,40,0.16), 0 0 0 2px rgba(114,216,197,0.3);
      padding: 20px 22px 24px;
      position: relative;
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 12px;
    }
    .modal-title {
      font-size: 1.35rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .modal-close {
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.15s ease;
    }
    .modal-close:hover {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--accent-soft);
    }
    .modal-sub {
      color: #ffffff;
      line-height: 1.4;
      font-size: 0.95rem;
      margin-bottom: 14px;
    }
    .modal-sections {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .modal-section {
      border: 2px solid rgba(114,216,197,0.6);
      border-radius: 12px;
      padding: 12px;
      background:
        linear-gradient(90deg, rgba(185,180,173,0.76) 0%, rgba(213,213,213,0.84) 55%, rgba(235,235,235,0.88) 100%),
        radial-gradient(circle at 22% 28%, rgba(114,216,197,0.06), transparent 44%),
        radial-gradient(circle at 80% 42%, rgba(122,138,196,0.04), transparent 46%);
      box-shadow: 0 8px 18px rgba(20,28,40,0.18), inset 0 0 0 2px rgba(114,216,197,0.2);
    }
    .modal-section.disabled {
      opacity: 0.6;
    }
    .modal-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }
    .modal-radio {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      font-size: 0.95rem;
      color: var(--text);
    }
    .modal-section-sub {
      color: #ffffff;
      font-size: 0.85rem;
    }
    .modal-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      align-items: start;
    }
    .modal-dual {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 12px;
    }
    .modal-card {
      border: 2px dashed rgba(114,216,197,0.6);
      border-radius: 12px;
      padding: 14px;
      min-height: 120px;
      color: #ffffff;
      background:
        linear-gradient(90deg, rgba(185,180,173,0.72) 0%, rgba(213,213,213,0.82) 55%, rgba(235,235,235,0.86) 100%),
        radial-gradient(circle at 22% 28%, rgba(114,216,197,0.05), transparent 44%),
        radial-gradient(circle at 80% 42%, rgba(122,138,196,0.03), transparent 46%);
    }
    .aa-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
    }
    .aa-table th,
    .aa-table td {
      border: 1px solid rgba(0,0,0,0.12);
      padding: 6px 8px;
      text-align: left;
      font-size: 0.9rem;
    }
    .aa-table input[type="number"] {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(0,0,0,0.15);
      background: rgba(255,255,255,0.8);
      color: #000000;
      font-weight: 600;
    }
    .add-aa-row {
      margin-top: 8px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,0.16);
      background: rgba(255,255,255,0.75);
      color: #000000;
      padding: 8px 12px;
      font-weight: 700;
      cursor: pointer;
    }
    .add-aa-row:hover {
      border-color: rgba(114,216,197,0.7);
      box-shadow: 0 0 0 2px rgba(114,216,197,0.2);
    }
    /* Modal text */
    .modal, .modal * {
      color: #000000;
      text-shadow: none;
      font-weight: 700;
    }
    .modal-section[data-mode="procs"] select {
      height: 25px;
      line-height: 25px;
    }
    .modal-card h4 {
      margin: 0 0 6px;
      color: #000000;
      letter-spacing: 0.01em;
    }

    /* Compact inline control rows in modal */
    .modal-control-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
      margin-top: -6px;
    }
    /* Inline the radio and controls for quick-preset and override rows */
    .modal-section[data-mode="procs"],
    .modal-section[data-mode="override"] {
      display: flex;
      align-items: center;
      gap: 14px;
      flex-wrap: wrap;
    }
    .modal-section[data-mode="procs"] .modal-section-header,
    .modal-section[data-mode="override"] .modal-section-header {
      margin: 0;
      justify-content: flex-start;
      gap: 8px;
    }
    .modal-section[data-mode="procs"] .modal-control-row,
    .modal-section[data-mode="override"] .modal-control-row {
      margin-top: 0;
      flex: 1 1 auto;
    }
  </style>
</head>
<body>
  <div class="hero">
    <div class="hero-content">
      <div class="hero-title">
        Stellaron Hunter // Firefly
        <span class="emblem">Turn timeline</span>
      </div>
      <div class="hero-sub">
        This is a calculator for Firefly's speed breakpoints now that Dahlia is a thing! Play around with the settings and see exactly when Firefly takes actions
      </div>
    </div>
  </div>

  <div class="shell">
    <div class="panel av-panel">
      <div class="panel-header">
        <div>
          <h1>
            AV calculator
            <span class="mark">Complete Combustion</span>
          </h1>
          <div class="subtitle">
            Adjust Firefly's SPD and buffs to see her AV timeline for this phase.
          </div>
        </div>
        <button class="panel-pin" id="pinToggleBtn">Freeze panel</button>
      </div>

      <div class="controls">
        <div class="controls-grid">
          <div class="control-group spd-group">
            <label for="spdNumber" class="buff-title">Firefly out of combat SPD</label>
            <input id="spdNumber" type="number" step="0.1" min="80" max="250" value="178.4" />
            <input id="spdSlider" type="range" step="0.1" min="80" max="250" value="178.4" />
          </div>
          <div class="control-group buff-group">
            <div class="buff-block">
              <input id="rmToggle" type="checkbox" />
              <div class="buff-text" id="rmTextBlock">
                <span class="buff-title">Ruan Mei</span>
                <span class="buff-sub" id="rmText">+10% of 104 = 10.4</span>
              </div>
            </div>
            <div class="buff-block">
              <input id="dahliaToggle" type="checkbox" checked />
              <div class="buff-text" id="dahliaTextBlock">
                <span class="buff-title">Dahlia A4</span>
                <span class="buff-sub" id="dahliaText">+30% of 104 = 31.2</span>
              </div>
            </div>
          </div>
          <div class="control-group e5-group">
            <div class="toggle">
              <input id="e5Toggle" type="checkbox" />
              <span class="buff-title">E5 <span class="buff-sub">(+6 SPD in CC)</span></span>
            </div>
            <div class="toggle-group">
              <span class="buff-title">Phainon LC</span>
              <select id="phainonSelect" class="phainon-select">
                <option value="0">Off</option>
                <option value="1">S1 (+12 base SPD)</option>
                <option value="2">S2 (+14 base SPD)</option>
                <option value="3">S3 (+16 base SPD)</option>
                <option value="4">S4 (+18 base SPD)</option>
                <option value="5">S5 (+20 base SPD)</option>
              </select>
            </div>
          </div>
          <div class="control-group ddd-group">
            <div class="mini-panel">
              <div class="mini-panel-header buff-title">DDD Proc's Per Ult</div>
              <div class="ddd-row">
                <div class="ddd-column">
                  <select id="dddSelect" class="ddd-proc-select" data-visible-rows="6">
                    <option value="0">0 DDD Proc's</option>
                    <option value="1">1 DDD Proc</option>
                    <option value="2">2 DDD Proc's</option>
                    <option value="3">3 DDD Proc's</option>
                    <option value="4">4 DDD Proc's</option>
                    <option value="5">5 DDD Proc's</option>
                    <option value="6">6 DDD Proc's</option>
                    <option value="7">7 DDD Proc's</option>
                    <option value="8">8 DDD Proc's</option>
                    <option value="9">9 DDD Proc's</option>
                    <option value="10">10 DDD Proc's</option>
                    <option value="11">11 DDD Proc's</option>
                    <option value="12">12 DDD Proc's</option>
                    <option value="13">13 DDD Proc's</option>
                    <option value="14">14 DDD Proc's</option>
                    <option value="15">15 DDD Proc's</option>
                  </select>
                  <select id="dddRankSelect" class="ddd-proc-select" data-visible-rows="6">
                    <option value="1">S1</option>
                    <option value="2">S2</option>
                    <option value="3">S3</option>
                    <option value="4">S4</option>
                    <option value="5" selected>S5</option>
                  </select>
                </div>
                <select id="dddModeSelect" class="ddd-dist-select" data-visible-rows="2" style="grid-column: 2; grid-row: 1;">
                  <option value="frontloaded">Frontloaded</option>
                  <option value="average" selected>Average</option>
                </select>
                <button class="ddd-adv" id="dddSettingsBtn" type="button" onclick="openDddModal()">
                  <span class="ddd-adv-line">Advanced DDD</span>
                  <span class="ddd-adv-line">Settings <span class="ddd-gear">&#9881;</span></span>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="summary">
        <div class="summary-item" id="summarySpd"></div>
        <div class="summary-item" id="summaryAv"></div>
      </div>
    </div>
    <div class="charts">
      <div class="panel chart-card">
        <div class="card-title">
          <span>Scenario A</span>
          <span class="pill">Think MoC phase 2</span>
        </div>
        <div class="card-sub">
          Firefly starts this phase already in CC.
        </div>
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Event</th>
              <th>AV</th>
            </tr>
          </thead>
          <tbody id="tableA"></tbody>
        </table>
      </div>

      <div class="panel chart-card">
        <div class="card-title">
          <span>Scenario B</span>
          <span class="pill">Think Anomaly Arbitration</span>
        </div>
        <div class="card-sub">
          Firefly starts out of CC, uses a Skill, then ults.
        </div>
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Event</th>
              <th>AV</th>
            </tr>
          </thead>
          <tbody id="tableB"></tbody>
        </table>
      </div>
    </div>

    <div class="panel">
      <div class="card-title">
        <span>Speed Breakpoints</span>
        <span class="pill">AV vs sheet SPD</span>
      </div>
        <div class="card-sub">
          Choose target AVs and a sheet SPD range. Each table shows which SPD bands give different EBA / Skill patterns before that AV.
        </div>
        <div class="controls" style="margin-bottom: 10px; display: flex; flex-wrap: wrap; gap: 8px; align-items: flex-start; flex-direction: row;">
          <div class="control-group inv-target" style="flex: 0 0 200px;">
            <label for="targetAvInputA">Scenario A target AV (MoC)</label>
            <input id="targetAvInputA" class="inv-target-input" type="number" step="1" min="50" max="600" value="150" />
          </div>
          <div class="control-group inv-target" style="flex: 0 0 200px;">
            <label for="targetAvInputB">Scenario B target AV (AA)</label>
            <input id="targetAvInputB" class="inv-target-input" type="number" step="1" min="50" max="600" value="300" />
          </div>
          <div class="control-group inv-target" style="flex: 0 0 220px;">
            <label>Sheet SPD scan range</label>
            <div style="display:flex; gap:8px;">
              <input id="invMinSpd" class="inv-target-input" type="number" step="0.1" min="80" max="260" value="104" />
              <input id="invMaxSpd" class="inv-target-input" type="number" step="0.1" min="80" max="260" value="220" />
            </div>
          </div>
        </div>
      <div class="preset-row">
        <span class="preset-label">MoC presets (Scenario A):</span>
        <button class="preset-btn preset-a" data-av="150">MoC 0 Cycle (150)</button>
        <button class="preset-btn preset-a" data-av="250">MoC 1 Cycle (250)</button>
        <button class="preset-btn preset-a" data-av="350">MoC 2 Cycle (350)</button>
      </div>
      <div class="preset-row">
        <span class="preset-label">AA presets (Scenario B):</span>
        <button class="preset-btn preset-b" data-av="300">AA 0 Cycle (300)</button>
        <button class="preset-btn preset-b" data-av="400">AA 1 Cycle (400)</button>
        <button class="preset-btn preset-b" data-av="500">AA 2 Cycle (500)</button>
      </div>
      <hr class="divider" />
      <div class="charts">
        <div class="chart-card">
          <div class="card-title">
            <span>Scenario A</span>
            <span class="pill">Think MoC phase 2</span>
          </div>
          <table>
            <thead>
              <tr>
                <th>Out of combat SPD</th>
                <th>Total EBA / Skill</th>
                <th>Pattern up to target AV</th>
              </tr>
            </thead>
            <tbody id="invTableA"></tbody>
          </table>
        </div>
        <div class="chart-card">
          <div class="card-title">
            <span>Scenario B</span>
            <span class="pill">Think Anomaly Arbitration</span>
          </div>
          <table>
            <thead>
              <tr>
                <th>Out of combat SPD</th>
                <th>Total EBA / Skill</th>
                <th>Pattern up to target AV</th>
              </tr>
            </thead>
            <tbody id="invTableB"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <div class="modal" id="dddModal" aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-header">
        <div>
          <div class="modal-title">Advanced DDD Settings</div>
          <div class="modal-sub">
            The % Action Advance is used to calculate how many EBA's will occur during CC. By default, 1 or 2 proc's of DDD (or sub 50% if you specify) will be Frontloaded during the ult (advances the first possible EBA), while higher amounts of AA defaults to Averaging out the AA over all EBA's. You can override this.
            <br /><br />
            For Average, the AA is evenly split over all applicable EBA's. For example, 5 S5 DDD proc's gives 120% AA. If it results in 4 EBA's that can be advanced, each of them will be treated as if they had 120% / 4 = 30% AA. This assumes all DDD proc's are not wasted and are used during CC only. You can either use the DDD presets, or input in exact AA for your use case. For example Dahlia E6 is 20%.
          </div>
        </div>
        <button class="modal-close" id="dddModalClose" type="button">Close</button>
      </div>

      <div class="modal-sections">
            <div class="modal-section" data-mode="procs">
              <div class="modal-section-header">
                <label class="modal-radio">
                  <input type="radio" name="dddMode" value="procs" checked />
                  
                </label>
                <span class="modal-section-sub"></span>
              </div>
              <div class="modal-control-row">
                <div style="display:flex; align-items:center; gap:6px; width:auto;">
                  <label for="dddSelectModal" style="margin:0;">DDD Proc's Per Ult</label>
                  <select id="dddSelectModal" class="ddd-proc-select" style="width: 140px;">
                <option value="0">0 DDD Proc's</option>
                <option value="1">1 DDD Proc's</option>
                <option value="2">2 DDD Proc's</option>
                <option value="3">3 DDD Proc's</option>
                <option value="4">4 DDD Proc's</option>
                <option value="5">5 DDD Proc's</option>
                <option value="6">6 DDD Proc's</option>
                <option value="7">7 DDD Proc's</option>
                <option value="8">8 DDD Proc's</option>
                <option value="9">9 DDD Proc's</option>
                <option value="10">10 DDD Proc's</option>
                <option value="11">11 DDD Proc's</option>
                <option value="12">12 DDD Proc's</option>
                <option value="13">13 DDD Proc's</option>
                <option value="14">14 DDD Proc's</option>
                <option value="15">15 DDD Proc's</option>
              </select>
            </div>
            <div style="display:flex; align-items:center; gap:6px; width:auto;">
                  <label for="dddRankSelectModal" style="margin:0;">DDD Superimposition</label>
                  <select id="dddRankSelectModal" class="ddd-proc-select" style="width: 110px;">
                    <option value="1">S1</option>
                    <option value="2">S2</option>
                    <option value="3">S3</option>
                    <option value="4">S4</option>
                    <option value="5" selected>S5</option>
                  </select>
                </div>
                <div style="display:flex; align-items:center; gap:6px; width:auto;">
                  <label for="dddModeSelectModalProcs" style="margin:0;">How to apply DDD procs</label>
                  <select id="dddModeSelectModalProcs" class="ddd-dist-select" style="width: 140px;">
                    <option value="frontloaded">Frontloaded</option>
                    <option value="average" selected>Average</option>
                  </select>
                </div>
              </div>
            </div>

            <div class="modal-section" data-mode="override">
              <div class="modal-section-header">
                <label class="modal-radio">
                  <input type="radio" name="dddMode" value="override" />
                  
                </label>
                <span class="modal-section-sub"></span>
              </div>
              <div class="modal-control-row">
                <label for="dddOverrideInput" style="margin:0;">Exact AA% Per Ult</label>
                <input id="dddOverrideInput" type="number" min="0" step="1" value="0" style="width: 100px;" />
                <div style="display:flex; align-items:center; gap:6px; width:auto;">
                  <label for="dddModeSelectModalOverride" style="margin:0;">How to apply DDD procs</label>
                  <select id="dddModeSelectModalOverride" class="ddd-dist-select" style="width: 140px;">
                    <option value="frontloaded">Frontloaded</option>
                    <option value="average" selected>Average</option>
                  </select>
                </div>
              </div>
            </div>

        <div class="modal-section" data-mode="future">
          <div class="modal-section-header">
            <label class="modal-radio">
              <input type="radio" name="dddMode" value="future" />
              Detailed AA at specific AV
            </label>
            <span class="modal-section-sub">You can specify the exact AV at which a certain AA procs. Like if you know at 75 AV, HMC will use DDD, then you can input that here.</span>
          </div>
          <div class="modal-dual">
            <div class="modal-card">
              <h4>Scenario A</h4>
              <table class="aa-table">
                <thead>
                  <tr>
                    <th>AV of the AA Proc</th>
                    <th>% AA</th>
                  </tr>
                </thead>
                <tbody id="aaTableBodyA"></tbody>
              </table>
              <button class="add-aa-row" type="button" data-scenario="A">Add AA row</button>
            </div>
            <div class="modal-card">
              <h4>Scenario B</h4>
              <table class="aa-table">
                <thead>
                  <tr>
                    <th>AV of the AA Proc</th>
                    <th>% AA</th>
                  </tr>
                </thead>
                <tbody id="aaTableBodyB"></tbody>
              </table>
              <button class="add-aa-row" type="button" data-scenario="B">Add AA row</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const BASE_SPD = 104;           // Firefly's base SPD without Phainon
    const CC_TIMER_AV = 10000 / 70; // ~142.857
    const MAX_AV = 500;

    const spdNumber = document.getElementById('spdNumber');
    const spdSlider = document.getElementById('spdSlider');
    const rmToggle = document.getElementById('rmToggle');
    const dahliaToggle = document.getElementById('dahliaToggle');
    const dddSelect = document.getElementById('dddSelect');
    const dddRankSelect = document.getElementById('dddRankSelect');
    const dddModeSelect = document.getElementById('dddModeSelect');
    const e5Toggle = document.getElementById('e5Toggle');
    const phainonSelect = document.getElementById('phainonSelect');
    const tableA = document.getElementById('tableA');
    const tableB = document.getElementById('tableB');
    const summarySpd = document.getElementById('summarySpd');
    const summaryAv = document.getElementById('summaryAv');
    const rmText = document.getElementById('rmText');
    const dahliaText = document.getElementById('dahliaText');
    const dddSettingsBtn = document.getElementById('dddSettingsBtn');
    const dddModal = document.getElementById('dddModal');
    const dddModalClose = document.getElementById('dddModalClose');
    const dddSelectModal = document.getElementById('dddSelectModal');
    const dddRankSelectModal = document.getElementById('dddRankSelectModal');
    const dddModeSelectModalProcs = document.getElementById('dddModeSelectModalProcs');
    const dddModeSelectModalOverride = document.getElementById('dddModeSelectModalOverride');
    const dddOverrideInput = document.getElementById('dddOverrideInput');
    const dddModeRadios = document.querySelectorAll('input[name="dddMode"]');

    const targetAvInputA = document.getElementById('targetAvInputA');
    const targetAvInputB = document.getElementById('targetAvInputB');
    const invMinSpdInput = document.getElementById('invMinSpd');
    const invMaxSpdInput = document.getElementById('invMaxSpd');
    const invTableA = document.getElementById('invTableA');
    const invTableB = document.getElementById('invTableB');
    const presetButtonsA = document.querySelectorAll('.preset-btn.preset-a');
    const presetButtonsB = document.querySelectorAll('.preset-btn.preset-b');
    const pinToggleBtn = document.getElementById('pinToggleBtn');
    const avPanel = document.querySelector('.av-panel');
    const hero = document.querySelector('.hero');
    const aaTableBodyA = document.getElementById('aaTableBodyA');
    const aaTableBodyB = document.getElementById('aaTableBodyB');
    const aaAddButtons = document.querySelectorAll('.add-aa-row');
    let panelPinned = false;

    function fmt(x) {
      return x.toFixed(2);
    }

    function buildRow(n, event, av, cls, aaHit) {
      const row = { n, event, av, cls: cls || '' };
      if (aaHit) row.aaHit = true;
      return row;
    }

    function getDDDLevel() {
      const v = parseInt(dddSelect.value, 10);
      if (isNaN(v)) return 0;
      return Math.min(15, Math.max(0, v));
    }

    function getDDDReduction() {
      const rank = parseInt(dddRankSelect.value, 10);
      switch (rank) {
        case 1: return 0.16;
        case 2: return 0.18;
        case 3: return 0.20;
        case 4: return 0.22;
        case 5: default: return 0.24;
      }
    }

    function getDddMode() {
      const checked = document.querySelector('input[name="dddMode"]:checked');
      return checked ? checked.value : 'procs';
    }

    function setDddMode(mode) {
      if (!dddModeRadios || !dddModeRadios.length) return;
      let changed = false;
      dddModeRadios.forEach(r => {
        if (r.value === mode && !r.checked) {
          r.checked = true;
          changed = true;
        }
      });
      if (changed) {
        refreshDddSectionStates();
      }
    }

    function getOverrideAA() {
      const val = parseFloat((dddOverrideInput && dddOverrideInput.value) || '0');
      if (isNaN(val) || val < 0) return 0;
      return val / 100;
    }

    function getTotalAA() {
      const mode = getDddMode();
      if (mode === 'override') {
        return getOverrideAA();
      }
      if (mode === 'future') {
        return 0;
      }
      // Standard procs mode
      const ddd = getDDDLevel();
      const dddReduction = getDDDReduction();
      return ddd * dddReduction;
    }

    function getPhainonBonus() {
      const level = parseInt(phainonSelect.value, 10);
      if (isNaN(level) || level <= 0) return 0;
      switch (level) {
        case 1: return 12;
        case 2: return 14;
        case 3: return 16;
        case 4: return 18;
        case 5: return 20;
        default: return 0;
      }
    }

    function getEffectiveBaseSpd() {
      return BASE_SPD + getPhainonBonus();
    }

    function getCcBonusSpd() {
      return e5Toggle && e5Toggle.checked ? 66 : 60;
    }

    function getSpeedProfile(sheetSpd) {
      const baseSpdEff = getEffectiveBaseSpd();
      let spdOut = sheetSpd;
      if (dahliaToggle.checked) spdOut += 0.3 * baseSpdEff;
      if (rmToggle.checked) spdOut += 0.1 * baseSpdEff;
      const spdCC = spdOut + getCcBonusSpd();
      return {
        spdOut,
        spdCC,
        baseAVOut: 10000 / spdOut,
        baseAVCC: 10000 / spdCC,
      };
    }

    // Track DDD distribution mode across main and modal dropdowns.
    let dddDistributionMode = 'average';
    let dddDistributionManual = false;

    // Placeholder for a future toggle. Now reads the shared distribution mode.
    function useFrontLoadedDDD() {
      return dddDistributionMode === 'frontloaded';
    }

    // Averaged AA distribution (existing behavior).
    function getEbaTimesAverage(baseAVCC, totalAAFrac, includeFirstInShare) {
      const T = CC_TIMER_AV;
      const eps = 1e-6;
      const F = Math.max(0, totalAAFrac);
      const baseCount = T / baseAVCC;

      if (includeFirstInShare) {
        const N = Math.max(0, Math.floor(baseCount + F + eps));
        if (N === 0) return [];
        const perShare = F / N;
        const delta = baseAVCC * (1 - perShare);
        const times = [];
        for (let k = 1; k <= N; k++) {
          times.push(delta * k);
        }
        return times.filter(t => t <= T + eps);
      }

      const Nshare = Math.max(0, Math.floor(baseCount + F + eps));
      const times = [0]; // EBA1 at CC start
      if (Nshare === 0) return times;
      const perShare = F / Nshare;
      const delta = baseAVCC * (1 - perShare);
      for (let k = 1; k <= Nshare; k++) {
        times.push(delta * k);
      }
      return times.filter(t => t <= T + eps);
    }

    // Front-loaded AA distribution: spend AA on the earliest eligible EBAs, up to 100% per EBA.
    function getEbaTimesFrontLoaded(baseAVCC, totalAAFrac, includeFirstInShare) {
      const T = CC_TIMER_AV;
      const eps = 1e-6;
      const F = Math.max(0, totalAAFrac);
      const baseCount = T / baseAVCC;

      if (includeFirstInShare) {
        const N = Math.max(0, Math.floor(baseCount + F + eps));
        if (N === 0) return [];
        let remaining = F;
        let last = 0;
        const times = [];
        for (let k = 1; k <= N; k++) {
          const share = Math.min(1, remaining);
          const delta = baseAVCC * (1 - share);
          last += delta;
          if (last <= T + eps) times.push(last);
          remaining = Math.max(0, remaining - share);
        }
        return times;
      }

      const Nshare = Math.max(0, Math.floor(baseCount + F + eps));
      let remaining = F;
      let last = 0;
      const times = [0]; // EBA1 at CC start and not advanced
      for (let k = 1; k <= Nshare; k++) {
        const share = Math.min(1, remaining);
        const delta = baseAVCC * (1 - share);
        last += delta;
        if (last <= T + eps) times.push(last);
        remaining = Math.max(0, remaining - share);
      }
      return times;
    }

    // Entrypoint: choose average vs front-loaded distribution.
    function getEbaTimes(baseAVCC, totalAAFrac, includeFirstInShare) {
      if (useFrontLoadedDDD()) {
        return getEbaTimesFrontLoaded(baseAVCC, totalAAFrac, includeFirstInShare);
      }
      return getEbaTimesAverage(baseAVCC, totalAAFrac, includeFirstInShare);
    }

    function addAaRow(body) {
      if (!body) return;
      const tr = document.createElement('tr');
      const tdAv = document.createElement('td');
      const tdPct = document.createElement('td');
      const avInput = document.createElement('input');
      avInput.type = 'number';
      avInput.min = '0';
      avInput.step = '0.1';
      avInput.className = 'aa-av';
      const pctInput = document.createElement('input');
      pctInput.type = 'number';
      pctInput.min = '0';
      pctInput.step = '0.1';
      pctInput.className = 'aa-pct';
      const recalc = () => {
        setDddMode('future');
        calculate();
      };
      avInput.addEventListener('input', recalc);
      pctInput.addEventListener('input', recalc);
      tdAv.appendChild(avInput);
      tdPct.appendChild(pctInput);
      tr.appendChild(tdAv);
      tr.appendChild(tdPct);
      body.appendChild(tr);
    }

    function parseAaEvents(body) {
      const events = [];
      if (!body) return events;
      body.querySelectorAll('tr').forEach(row => {
        const av = parseFloat(row.querySelector('.aa-av')?.value || '');
        const pct = parseFloat(row.querySelector('.aa-pct')?.value || '');
        if (!isNaN(av) && av >= 0 && !isNaN(pct) && pct > 0) {
          events.push({ av, frac: pct / 100 });
        }
      });
      events.sort((a, b) => a.av - b.av);
      return events;
    }

    function buildFutureScenario(scenario, baseAVOut, baseAVCC, aaEvents, maxAvOverride) {
      const rows = [];
      const maxRows = 800;
      aaEvents = (aaEvents || []).slice().sort((a, b) => a.av - b.av);
      const maxAv = typeof maxAvOverride === 'number' ? maxAvOverride : MAX_AV;

      let idx = 1;
      let t = 0;
      let inCC = scenario === 'A';
      let ccEnd = inCC ? CC_TIMER_AV : Infinity;
      let need = inCC ? baseAVCC : baseAVOut;
      let cycle = inCC ? 1 : 0;
      let ebaInCycle = 0;
      let skillIndex = 0;
      let aaIdx = 0;
      let aaTouched = false;

      rows.push(buildRow(idx++, `Phase start (${inCC ? 'CC' : 'no CC'})`, t, 'event-phase'));

      while (t <= maxAv + 1 && rows.length < maxRows) {
        const tAA = aaIdx < aaEvents.length ? aaEvents[aaIdx].av : Infinity;
        const tCcEnd = inCC ? ccEnd : Infinity;
        const tAction = t + need;
        const tNext = Math.min(tAA, tCcEnd, tAction);

        if (!isFinite(tNext)) break;

        if (tAA <= tAction && tAA < tCcEnd) {
          const elapsed = tAA - t;
          need = Math.max(0, need - elapsed);
          t = tAA;
          const base = inCC ? baseAVCC : baseAVOut;
          const effect = Math.max(0, aaEvents[aaIdx].frac * base);
          if (effect > 0) aaTouched = true;
          need = Math.max(0, need - effect);
          aaIdx++;
          continue;
        }

        if (inCC && tCcEnd <= tAction && tCcEnd <= tAA) {
          const elapsed = tCcEnd - t;
          need = Math.max(0, need - elapsed);
          t = tCcEnd;
          rows.push(buildRow(idx++, 'CC ends', t, 'event-cc'));
          need = need * (baseAVOut / baseAVCC);
          inCC = false;
          ccEnd = Infinity;
          continue;
        }

        // Action fires
        const elapsed = tAction - t;
        need = Math.max(0, need - elapsed);
        t = tAction;

        const hit = aaTouched;
        aaTouched = false;

        if (inCC) {
          if (cycle > 1 && ebaInCycle === 0) {
            // First CC action in a fresh cycle was already logged when the CC started.
          }
          if (ebaInCycle === 0) {
            ebaInCycle = 1;
            rows.push(buildRow(idx++, 'EBA 1', t, 'event-eba', hit));
          } else {
            ebaInCycle++;
            rows.push(buildRow(idx++, `EBA ${ebaInCycle}`, t, 'event-eba', hit));
          }
          need = baseAVCC;
        } else {
          skillIndex++;
          const label = (scenario === 'B' && skillIndex === 1)
            ? `Skill ${skillIndex} (opening)`
            : `Skill ${skillIndex} (post-CC)`;
          rows.push(buildRow(idx++, label, t, 'event-skill', hit));

          // Start CC immediately and log Ult & EBA1 at the same AV.
          cycle += 1;
          inCC = true;
          ebaInCycle = 0;
          ccEnd = t + CC_TIMER_AV;
          rows.push(buildRow(idx++, `Ult & EBA 1 (ult ${cycle})`, t, 'event-ult', hit));
          ebaInCycle = 1;
          need = baseAVCC;
        }
      }

      return rows.filter(r => r.av <= MAX_AV + 1);
    }

    // Sync all distribution dropdowns and optionally recalc.
    function setDddDistributionMode(mode, shouldRecalc = true, markManual = false) {
      const val = mode === 'frontloaded' ? 'frontloaded' : 'average';
      dddDistributionMode = val;
      if (markManual) dddDistributionManual = true;
      [dddModeSelect, dddModeSelectModalProcs, dddModeSelectModalOverride].forEach(sel => {
        if (sel && sel.value !== val) sel.value = val;
      });
      if (shouldRecalc) calculate();
    }

    function maybeAutoSetDistributionFromProcs(procsVal) {
      if (dddDistributionManual) return;
      let v = procsVal;
      if (typeof v !== 'number') {
        v = parseInt((dddSelect && dddSelect.value) || (dddSelectModal && dddSelectModal.value) || '', 10);
      }
      if (isNaN(v)) return;
      if (v === 1 || v === 2) {
        setDddDistributionMode('frontloaded');
      } else if (v >= 3) {
        setDddDistributionMode('average');
      }
    }

    function maybeAutoSetDistributionFromOverride(pctVal) {
      if (dddDistributionManual) return;
      let p = pctVal;
      if (typeof p !== 'number') {
        p = parseFloat((dddOverrideInput && dddOverrideInput.value) || '');
      }
      if (isNaN(p)) return;
      if (p < 50) {
        setDddDistributionMode('frontloaded');
      } else if (p > 50) {
        setDddDistributionMode('average');
      }
    }
    function syncDddModalFromMain() {
      if (dddSelectModal && dddSelect) dddSelectModal.value = dddSelect.value;
      if (dddRankSelectModal && dddRankSelect) dddRankSelectModal.value = dddRankSelect.value;
      const modeVal = dddModeSelect ? dddModeSelect.value : dddDistributionMode;
      setDddDistributionMode(modeVal, false);
    }

    function syncMainFromDddModal() {
      if (dddSelect && dddSelectModal) dddSelect.value = dddSelectModal.value;
      if (dddRankSelect && dddRankSelectModal) dddRankSelect.value = dddRankSelectModal.value;
      const modeVal = dddModeSelectModalProcs ? dddModeSelectModalProcs.value : dddDistributionMode;
      setDddDistributionMode(modeVal, false);
    }

    function refreshDddSectionStates() {
      const mode = getDddMode();
      document.querySelectorAll('.modal-section').forEach(sec => {
        const secMode = sec.getAttribute('data-mode');
        if (secMode && secMode !== mode) {
          sec.classList.add('disabled');
        } else {
          sec.classList.remove('disabled');
        }
      });
    }

    function openDddModal() {
      syncDddModalFromMain();
      refreshDddSectionStates();
      if (dddModal) {
        dddModal.classList.add('active');
        dddModal.setAttribute('aria-hidden', 'false');
      }
    }

    function closeDddModal() {
      if (dddModal) {
        dddModal.classList.remove('active');
        dddModal.setAttribute('aria-hidden', 'true');
      }
    }

    function getRangeClass(av, scenario) {
      if (typeof av !== 'number' || isNaN(av)) return '';
      if (scenario === 'A') {
        if (av <= 150) return 'range-a0';
        if (av > 150 && av <= 250) return 'range-a1';
        if (av > 250 && av <= 350) return 'range-a2';
        if (av > 350 && av <= 450) return 'range-a3';
        if (av > 450 && av <= 550) return 'range-a4';
      } else if (scenario === 'B') {
        if (av <= 300) return 'range-b0';
        if (av > 300 && av <= 400) return 'range-b1';
        if (av > 400 && av <= 500) return 'range-b2';
        if (av > 500 && av <= 600) return 'range-b3';
      }
      return '';
    }

    function describePattern(events, targetAv) {
      if (!events.length) {
        return `No EBA / Skill before AV ${fmt(targetAv)}`;
      }
      const groups = [];
      let last = events[0];
      let count = 1;
      for (let i = 1; i < events.length; i++) {
        if (events[i] === last) {
          count++;
        } else {
          groups.push({ type: last, count });
          last = events[i];
          count = 1;
        }
      }
      groups.push({ type: last, count });

      return groups
        .map(g => {
          if (g.type === 'E') {
            return `${g.count} EBA`;
          }
          return `${g.count} Skill`;
        })
        .join(' ');
    }

    function patternScenarioA(sheetSpd, targetAv) {
      const { spdOut, spdCC, baseAVOut, baseAVCC } = getSpeedProfile(sheetSpd);
      const mode = getDddMode();
      if (mode === 'future') {
        const rows = buildFutureScenario('A', baseAVOut, baseAVCC, parseAaEvents(aaTableBodyA), targetAv);
        const eps = 1e-6;
        return rows
          .filter(r => r.av <= targetAv + eps && (r.cls.includes('event-eba') || r.cls.includes('event-ult') || r.cls.includes('event-skill')))
          .map(r => {
            if (r.cls.includes('event-skill')) return 'N';
            return 'E';
          });
      }
      const totalAA = getTotalAA();
      const events = [];
      const eps = 1e-6;

      // First CC cycle at AV 0
      let ccStart = 0;
      let ccEnd = ccStart + CC_TIMER_AV;
      const ebaTimesFirst = getEbaTimes(baseAVCC, totalAA, true);
      let lastCCActionAv = 0;
      ebaTimesFirst.forEach(t => {
        const at = ccStart + t;
        if (at <= targetAv + eps) events.push('E');
        lastCCActionAv = at;
      });

      if (!lastCCActionAv) return events; // no EBAs fit

      let passed = ccEnd - lastCCActionAv;
      let remainingOld = Math.max(0, baseAVCC - passed);
      let scale = spdCC / spdOut;
      let newRemaining = remainingOld * scale;
      let skillTime = ccEnd + newRemaining;
      if (skillTime <= targetAv + eps) {
        events.push('N');
      } else {
        return events;
      }

      while (true) {
        const ccStartLoop = skillTime;
        const ccEndLoop = ccStartLoop + CC_TIMER_AV;

        if (ccStartLoop <= targetAv + eps) {
          events.push('E'); // Ult & EBA 1
        } else {
          break;
        }

        const ebaTimesLoop = getEbaTimes(baseAVCC, totalAA, false);
        let lastCCActionAvLoop = ccStartLoop;
        for (let j = 1; j < ebaTimesLoop.length; j++) {
          const at = ccStartLoop + ebaTimesLoop[j];
          if (at <= targetAv + eps) events.push('E');
          lastCCActionAvLoop = at;
        }

        const passedLoop = ccEndLoop - lastCCActionAvLoop;
        const remainingOldLoop = Math.max(0, baseAVCC - passedLoop);
        const scaleLoop = spdCC / spdOut;
        const newRemainingLoop = remainingOldLoop * scaleLoop;
        const nextSkillTime = ccEndLoop + newRemainingLoop;

        if (nextSkillTime <= targetAv + eps) {
          events.push('N');
          skillTime = nextSkillTime;
        } else {
          break;
        }
      }

      return events;
    }

    function patternScenarioB(sheetSpd, targetAv) {
      const { spdOut, spdCC, baseAVOut, baseAVCC } = getSpeedProfile(sheetSpd);
      const mode = getDddMode();
      if (mode === 'future') {
        const rows = buildFutureScenario('B', baseAVOut, baseAVCC, parseAaEvents(aaTableBodyB), targetAv);
        const eps = 1e-6;
        return rows
          .filter(r => r.av <= targetAv + eps && (r.cls.includes('event-eba') || r.cls.includes('event-ult') || r.cls.includes('event-skill')))
          .map(r => {
            if (r.cls.includes('event-skill')) return 'N';
            return 'E';
          });
      }
      const totalAA = getTotalAA();
      const events = [];
      const eps = 1e-6;

      // Opening Skill out of CC
      const skill1Av = baseAVOut;
      if (skill1Av <= targetAv + eps) events.push('N');

      // First CC cycle
      let ccStart = skill1Av;
      let ccEnd = ccStart + CC_TIMER_AV;
      if (ccStart <= targetAv + eps) events.push('E'); // Ult & EBA 1

      const ebaTimesFirst = getEbaTimes(baseAVCC, totalAA, false);
      let lastCCActionAv = ccStart;
      for (let j = 1; j < ebaTimesFirst.length; j++) {
        const at = ccStart + ebaTimesFirst[j];
        if (at <= targetAv + eps) events.push('E');
        lastCCActionAv = at;
      }

      let passed = ccEnd - lastCCActionAv;
      let remainingOld = Math.max(0, baseAVCC - passed);
      let scale = spdCC / spdOut;
      let newRemaining = remainingOld * scale;
      let skillTime = ccEnd + newRemaining;
      if (skillTime <= targetAv + eps) {
        events.push('N');
      } else {
        return events;
      }

      while (true) {
        const ccStartLoop = skillTime;
        const ccEndLoop = ccStartLoop + CC_TIMER_AV;

        if (ccStartLoop <= targetAv + eps) {
          events.push('E'); // Ult & EBA 1
        } else {
          break;
        }

        const ebaTimesLoop = getEbaTimes(baseAVCC, totalAA, false);
        let lastCCActionAvLoop = ccStartLoop;
        for (let j = 1; j < ebaTimesLoop.length; j++) {
          const at = ccStartLoop + ebaTimesLoop[j];
          if (at <= targetAv + eps) events.push('E');
          lastCCActionAvLoop = at;
        }

        const passedLoop = ccEndLoop - lastCCActionAvLoop;
        const remainingOldLoop = Math.max(0, baseAVCC - passedLoop);
        const scaleLoop = spdCC / spdOut;
        const newRemainingLoop = remainingOldLoop * scaleLoop;
        const nextSkillTime = ccEndLoop + newRemainingLoop;

        if (nextSkillTime <= targetAv + eps) {
          events.push('N');
          skillTime = nextSkillTime;
        } else {
          break;
        }
      }

      return events;
    }

    function buildRanges(minSpd, maxSpd, targetAv, scenario) {
      const ranges = [];
      const step = 0.1;
      const eps = 1e-6;

      function patternAt(spd) {
        const events = scenario === 'A'
          ? patternScenarioA(spd, targetAv)
          : patternScenarioB(spd, targetAv);
        const pattern = describePattern(events, targetAv);
        let eCount = 0;
        let nCount = 0;
        for (const ev of events) {
          if (ev === 'E') eCount++;
          else if (ev === 'N') nCount++;
        }
        return { pattern, eCount, nCount };
      }

      let current = null;
      let startSpd = null;

      for (let spd = minSpd; spd <= maxSpd + eps; spd += step) {
        const spdRounded = parseFloat(spd.toFixed(1));
        const pat = patternAt(spdRounded);
        if (current === null) {
          current = pat;
          startSpd = spdRounded;
        } else if (pat.pattern !== current.pattern || pat.eCount !== current.eCount || pat.nCount !== current.nCount) {
          const prevSpd = parseFloat((spdRounded - step).toFixed(1));
          ranges.push({
            start: startSpd,
            end: prevSpd,
            pattern: current.pattern,
            eCount: current.eCount,
            nCount: current.nCount,
          });
          current = pat;
          startSpd = spdRounded;
        }
      }

      if (current !== null && startSpd !== null) {
        const maxRounded = parseFloat(maxSpd.toFixed(1));
        ranges.push({
          start: startSpd,
          end: maxRounded,
          pattern: current.pattern,
          eCount: current.eCount,
          nCount: current.nCount,
        });
      }

      return ranges;
    }

    function formatRange(range, maxSpd) {
      const start = range.start.toFixed(1);
      const end = range.end.toFixed(1);
      const eps = 1e-6;
      if (range.end >= maxSpd - eps) {
        return `${start}`;
      }
      return `${start} - ${end}`;
    }

    function runInverse() {
      let targetAvA = parseFloat(targetAvInputA.value);
      if (isNaN(targetAvA) || targetAvA <= 0) targetAvA = 150;

      let targetAvB = parseFloat(targetAvInputB.value);
      if (isNaN(targetAvB) || targetAvB <= 0) targetAvB = 300;

      let minSpd = parseFloat(invMinSpdInput.value);
      let maxSpd = parseFloat(invMaxSpdInput.value);
      if (isNaN(minSpd)) minSpd = 104;
      if (isNaN(maxSpd)) maxSpd = 220;
      if (maxSpd < minSpd + 0.1) maxSpd = minSpd + 0.1;

      const rangesA = buildRanges(minSpd, maxSpd, targetAvA, 'A');
      const rangesB = buildRanges(minSpd, maxSpd, targetAvB, 'B');

      invTableA.innerHTML = rangesA
        .map((r, idx) => `
          <tr>
            <td class="av-col">${formatRange(r, maxSpd)}</td>
            <td>${r.eCount} EBA / ${r.nCount} Skill</td>
            <td>${r.pattern}</td>
          </tr>
        `)
        .join('');

      invTableB.innerHTML = rangesB
        .map((r, idx) => `
          <tr>
            <td class="av-col">${formatRange(r, maxSpd)}</td>
            <td>${r.eCount} EBA / ${r.nCount} Skill</td>
            <td>${r.pattern}</td>
          </tr>
        `)
        .join('');
    }

    function calculate() {
      let S = parseFloat(spdNumber.value);
      if (isNaN(S) || S <= 0) S = 178.4;

      const baseSpdEff = getEffectiveBaseSpd();
      const rmBonus = 0.1 * baseSpdEff;
      const dahliaBonus = 0.3 * baseSpdEff;
      if (rmText) rmText.textContent = `+10% of ${baseSpdEff.toFixed(0)} = ${rmBonus.toFixed(1)}`;
      if (dahliaText) dahliaText.textContent = `+30% of ${baseSpdEff.toFixed(0)} = ${dahliaBonus.toFixed(1)}`;

      let spdOut = S;
      if (dahliaToggle.checked) spdOut += 0.3 * baseSpdEff;
      if (rmToggle.checked) spdOut += 0.1 * baseSpdEff;

      let spdCC = spdOut + getCcBonusSpd();

      const baseAVOut = 10000 / spdOut;
      const baseAVCC = 10000 / spdCC;
      const mode = getDddMode();
      const totalAA = getTotalAA();
      const eps = 1e-6;

      summarySpd.innerHTML = `
        <span class="summary-label">SPD</span>
        <span class="summary-value">out: ${fmt(spdOut)}</span>
        <span class="summary-label">/ in CC: </span>
        <span class="summary-value">${fmt(spdCC)}</span>
      `;
      summaryAv.innerHTML = `
        <span class="summary-label">AV per turn</span>
        <span class="summary-value">out: ${fmt(baseAVOut)}</span>
        <span class="summary-label">/ in CC: </span>
        <span class="summary-value">${fmt(baseAVCC)}</span>
        <span class="summary-label">CC timer: </span>
        <span class="summary-value">${fmt(CC_TIMER_AV)}</span>
      `;

      let rowsA = [];
      let rowsB = [];

      if (mode === 'future') {
        const aaEventsA = parseAaEvents(aaTableBodyA);
        const aaEventsB = parseAaEvents(aaTableBodyB);
        rowsA = buildFutureScenario('A', baseAVOut, baseAVCC, aaEventsA);
        rowsB = buildFutureScenario('B', baseAVOut, baseAVCC, aaEventsB);
      } else {
        // Scenario A
        let idxA = 1;
        rowsA.push(buildRow(idxA++, 'Phase start (CC)', 0, 'event-phase'));

        let ccStart = 0;
        let ccEnd = ccStart + CC_TIMER_AV;
        const ebaTimesFirst = getEbaTimes(baseAVCC, totalAA, true);
        let lastCCActionAv = 0;
        ebaTimesFirst.forEach((t, i) => {
          const at = ccStart + t;
          rowsA.push(buildRow(idxA++, `EBA ${i + 1}`, at, 'event-eba'));
          lastCCActionAv = at;
        });
        rowsA.push(buildRow(idxA++, 'CC ends', ccEnd, 'event-cc'));

        let skillIndexA = 0;
        let postCCSkillTimeA = null;
        if (lastCCActionAv > 0) {
          const passed = ccEnd - lastCCActionAv;
          const remainingOld = Math.max(0, baseAVCC - passed);
          const scale = spdCC / spdOut;
          const newRemaining = remainingOld * scale;
          postCCSkillTimeA = ccEnd + newRemaining;
          skillIndexA++;
          rowsA.push(buildRow(idxA++, `Skill ${skillIndexA} (post-CC)`, postCCSkillTimeA, 'event-skill'));
        }

        let cycleA = 2;
        let loopSkillTimeA = postCCSkillTimeA;

        while (loopSkillTimeA != null) {
          rowsA.push(buildRow(idxA++, `Ult & EBA 1 (ult ${cycleA})`, loopSkillTimeA, 'event-ult'));

          ccStart = loopSkillTimeA;
          ccEnd = ccStart + CC_TIMER_AV;

          const ebaTimesLoop = getEbaTimes(baseAVCC, totalAA, false);
          let lastCCActionAvLoop = ccStart;
          for (let j = 1; j < ebaTimesLoop.length; j++) {
            const at = ccStart + ebaTimesLoop[j];
            rowsA.push(buildRow(idxA++, `EBA ${j + 1}`, at, 'event-eba'));
            lastCCActionAvLoop = at;
          }
          rowsA.push(buildRow(idxA++, 'CC ends', ccEnd, 'event-cc'));

          const passedLoop = ccEnd - lastCCActionAvLoop;
          const remainingOldLoop = Math.max(0, baseAVCC - passedLoop);
          const scaleLoop = spdCC / spdOut;
          const newRemainingLoop = remainingOldLoop * scaleLoop;
          loopSkillTimeA = ccEnd + newRemainingLoop;
          skillIndexA++;
          rowsA.push(buildRow(idxA++, `Skill ${skillIndexA} (post-CC)`, loopSkillTimeA, 'event-skill'));

          if (loopSkillTimeA > MAX_AV) {
            break;
          }

          cycleA++;
        }

        // Scenario B
        let idxB = 1;
        rowsB.push(buildRow(idxB++, 'Phase start (no CC)', 0, 'event-phase'));

        const skill1Av = baseAVOut;
        let skillIndexB = 0;
        skillIndexB++;
        rowsB.push(buildRow(idxB++, `Skill ${skillIndexB} (opening)`, skill1Av, 'event-skill'));

        let ccStartB = skill1Av;
        let ccEndB = ccStartB + CC_TIMER_AV;
        rowsB.push(buildRow(idxB++, 'Ult & EBA 1 (ult 1)', ccStartB, 'event-ult'));

        const ebaTimesFirstB = getEbaTimes(baseAVCC, totalAA, false);
        let lastCCActionAvB = ccStartB;
        for (let j = 1; j < ebaTimesFirstB.length; j++) {
          const at = ccStartB + ebaTimesFirstB[j];
          rowsB.push(buildRow(idxB++, `EBA ${j + 1}`, at, 'event-eba'));
          lastCCActionAvB = at;
        }
        rowsB.push(buildRow(idxB++, 'CC ends', ccEndB, 'event-cc'));

        let postCCSkillTimeB = null;
        if (lastCCActionAvB > 0) {
          const passedB = ccEndB - lastCCActionAvB;
          const remainingOldB = Math.max(0, baseAVCC - passedB);
          const scaleB = spdCC / spdOut;
          const newRemainingB = remainingOldB * scaleB;
          postCCSkillTimeB = ccEndB + newRemainingB;
          skillIndexB++;
          rowsB.push(buildRow(idxB++, `Skill ${skillIndexB} (post-CC)`, postCCSkillTimeB, 'event-skill'));
        }

        let cycleB = 2;
        let loopSkillTimeB = postCCSkillTimeB;

        while (loopSkillTimeB != null) {
          rowsB.push(buildRow(idxB++, `Ult & EBA 1 (ult ${cycleB})`, loopSkillTimeB, 'event-ult'));

          ccStartB = loopSkillTimeB;
          ccEndB = ccStartB + CC_TIMER_AV;

          const ebaTimesLoopB = getEbaTimes(baseAVCC, totalAA, false);
          let lastCCActionAvLoopB = ccStartB;
          for (let j = 1; j < ebaTimesLoopB.length; j++) {
            const at = ccStartB + ebaTimesLoopB[j];
            rowsB.push(buildRow(idxB++, `EBA ${j + 1}`, at, 'event-eba'));
            lastCCActionAvLoopB = at;
          }
          rowsB.push(buildRow(idxB++, 'CC ends', ccEndB, 'event-cc'));

          const passedLoopB = ccEndB - lastCCActionAvLoopB;
          const remainingOldLoopB = Math.max(0, baseAVCC - passedLoopB);
          const scaleLoopB = spdCC / spdOut;
          const newRemainingLoopB = remainingOldLoopB * scaleLoopB;
          loopSkillTimeB = ccEndB + newRemainingLoopB;
          skillIndexB++;
          rowsB.push(buildRow(idxB++, `Skill ${skillIndexB} (post-CC)`, loopSkillTimeB, 'event-skill'));

          if (loopSkillTimeB > MAX_AV) {
            break;
          }

          cycleB++;
        }
      }

      tableA.innerHTML = rowsA
        .map(r => {
          const band = getRangeClass(r.av, 'A');
          const aaAttr = r.aaHit ? ' data-aa-hit="1"' : '';
          return `<tr class="${r.cls} ${band}"${aaAttr}><td>${r.n}</td><td>${r.event}</td><td class="av-col">${fmt(r.av)}</td></tr>`;
        })
        .join('');

      tableB.innerHTML = rowsB
        .map(r => {
          const band = getRangeClass(r.av, 'B');
          const aaAttr = r.aaHit ? ' data-aa-hit="1"' : '';
          return `<tr class="${r.cls} ${band}"${aaAttr}><td>${r.n}</td><td>${r.event}</td><td class="av-col">${fmt(r.av)}</td></tr>`;
        })
        .join('');

      runInverse();
    }

    spdNumber.addEventListener('input', () => {
      spdSlider.value = spdNumber.value;
      calculate();
    });
    spdSlider.addEventListener('input', () => {
      spdNumber.value = spdSlider.value;
      calculate();
    });
    rmToggle.addEventListener('change', calculate);
    dahliaToggle.addEventListener('change', calculate);
    dddSelect.addEventListener('change', () => {
      setDddMode('procs');
      if (dddSelectModal) dddSelectModal.value = dddSelect.value;
      maybeAutoSetDistributionFromProcs(parseInt(dddSelect.value, 10));
      calculate();
    });
    dddRankSelect.addEventListener('change', () => {
      setDddMode('procs');
      if (dddRankSelectModal) dddRankSelectModal.value = dddRankSelect.value;
      calculate();
    });
    if (dddModeSelect) {
      dddModeSelect.addEventListener('change', () => {
        setDddDistributionMode(dddModeSelect.value, true, true);
      });
    }
    e5Toggle.addEventListener('change', calculate);
    phainonSelect.addEventListener('change', calculate);

    targetAvInputA.addEventListener('input', runInverse);
    targetAvInputB.addEventListener('input', runInverse);
    invMinSpdInput.addEventListener('input', runInverse);
    invMaxSpdInput.addEventListener('input', runInverse);

    presetButtonsA.forEach(btn => {
      btn.addEventListener('click', () => {
        const av = parseFloat(btn.getAttribute('data-av'));
        if (!isNaN(av)) {
          targetAvInputA.value = av;
          runInverse();
        }
      });
    });

    presetButtonsB.forEach(btn => {
      btn.addEventListener('click', () => {
        const av = parseFloat(btn.getAttribute('data-av'));
        if (!isNaN(av)) {
          targetAvInputB.value = av;
          runInverse();
        }
      });
    });

    aaAddButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const scenario = btn.getAttribute('data-scenario');
        const body = scenario === 'B' ? aaTableBodyB : aaTableBodyA;
        addAaRow(body);
        setDddMode('future');
      });
    });

    function ensureAaInitialRows() {
      if (aaTableBodyA && !aaTableBodyA.children.length) addAaRow(aaTableBodyA);
      if (aaTableBodyB && !aaTableBodyB.children.length) addAaRow(aaTableBodyB);
    }

    if (dddSelectModal) {
      dddSelectModal.addEventListener('change', () => {
        setDddMode('procs');
        syncMainFromDddModal();
        maybeAutoSetDistributionFromProcs(parseInt(dddSelectModal.value, 10));
        calculate();
      });
    }
    if (dddRankSelectModal) {
      dddRankSelectModal.addEventListener('change', () => {
        setDddMode('procs');
        syncMainFromDddModal();
        calculate();
      });
    }
    if (dddModeSelectModalProcs) {
      dddModeSelectModalProcs.addEventListener('change', () => {
        setDddDistributionMode(dddModeSelectModalProcs.value, true, true);
      });
    }
    if (dddModeSelectModalOverride) {
      dddModeSelectModalOverride.addEventListener('change', () => {
        setDddDistributionMode(dddModeSelectModalOverride.value, true, true);
      });
    }
    if (dddOverrideInput) {
      dddOverrideInput.addEventListener('input', () => {
        setDddMode('override');
        maybeAutoSetDistributionFromOverride(parseFloat(dddOverrideInput.value));
        calculate();
      });
    }
    if (dddModeRadios && dddModeRadios.length) {
      dddModeRadios.forEach(radio => {
        radio.addEventListener('change', () => {
          refreshDddSectionStates();
          calculate();
        });
      });
    }
    if (dddSettingsBtn) {
      dddSettingsBtn.addEventListener('click', openDddModal);
    }
    if (dddModalClose) {
      dddModalClose.addEventListener('click', closeDddModal);
    }
    if (dddModal) {
      dddModal.addEventListener('click', (e) => {
        if (e.target === dddModal) {
          closeDddModal();
        }
      });
    }
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        closeDddModal();
      }
    });

    function applyPinState() {
      if (!avPanel) return;
      if (panelPinned) {
        avPanel.classList.add('pinned');
        if (hero) hero.classList.add('hidden');
        pinToggleBtn.textContent = 'Unfreeze panel';
      } else {
        avPanel.classList.remove('pinned');
        if (hero) hero.classList.remove('hidden');
        pinToggleBtn.textContent = 'Freeze panel';
      }
    }

    if (pinToggleBtn) {
      pinToggleBtn.addEventListener('click', () => {
        panelPinned = !panelPinned;
        applyPinState();
      });
    }

    ensureAaInitialRows();
    // Initialize distribution mode from main dropdown (or default).
    setDddDistributionMode(dddModeSelect ? dddModeSelect.value : dddDistributionMode, false);
    // Apply auto defaults based on current proc/override settings, unless user overrides later.
    maybeAutoSetDistributionFromProcs();
    maybeAutoSetDistributionFromOverride();
    calculate();
    applyPinState();
    syncDddModalFromMain();
    refreshDddSectionStates();
  </script>
</body>

</html>
